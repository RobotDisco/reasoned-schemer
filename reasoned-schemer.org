#+TITLE: The Reasoned Schemer

* =core.logic=, not scheme

Remember that we're using core.logic instead of whatever scheme the book uses. Keep the following differences in mind: https://github.com/clojure/core.logic/wiki/Differences-from-The-Reasoned-Schemer

* Preamble
Remember to load core.logic

#+begin_src emacs-lisp
(require 'ob-clojure)
#+end_src

#+begin_src clojure :results silent
  (require '[clojure.core.logic :refer [run* u# s# == fresh conde lcons lcons?]])

  ;; `core.logic` no longer has `defrel`. Thanks to Alexander Fertman via cscabal for this snippet.
  ;; In hindsight I could have realized this from the footnote in chapter 1 frame 82.

  (defmacro defrel
    [rel arglist & goals]
    `(defn ~rel ~arglist
       (fn
	 ;; Why is this s# when the book is (s) not (#s)?
	 ;; Oh in a clojure macro s# is a gensymed symbol, not our core.logic
	 ;;symbol for unconditional success?
	 [s#]
	 (fn
	   []
	   ((conde [~@goals]) s#)))))

  ;; chapter 2, frame 6
  (defrel caro [p a]
    (fresh [d]
      (== (lcons a d) p)))
  ;; chapter 2, frame 13
  (defrel cdro [p d]
    (fresh [a]
      (== (lcons a d) p)))
  ;; chapter 2, frame 25
  (defrel conso1 [a d p]
    (caro p a)
    (cdro p d))
  ;; chapter 2, frame 26
  (defrel conso [a d p]
    (== (lcons a d) p))
  ;; chapter 2, frame 33
  (defrel nullo [x]
    ;; We are pretending to be scheme, so we will pretend `nil` does not exist
    (== '() x))
  ;; Chapter 2 frame 46
  (defrel pairo [p]
    (fresh [a d]
      (conso a d p)))
  ;; Clojure doesn't have pair?
  ;; so stealing it from https://github.com/clojure/core.logic/wiki/Differences-from-The-Reasoned-Schemer
  (defn pair? [x]
    (or (lcons? x) (and (coll? x) (seq x))))
  ;; Chapter 2 frame 58
  (defn singleton? [l]
    (cond
      (pair? l) (empty? (rest l))
      :else false))
  ;; Chapter 2 frame 64
  (defrel singletono [l]
    (conde
     [(pairo l)]
     [(fresh (d)
	(cdro l d)
	(nullo d))]
     [(s# u#)]))
#+end_src

* Chapter 1. Playthings
** Frame 7
- ~u#~ :: A goal that can never be met
- ~s#~ :: A goal that is always met

#+begin_src clojure :results pp
  (run* [q] u#)
#+end_src

#+RESULTS:
: ()
: 

** Frame 10
- ~==~ :: Succeed if the first value is the same as the second

    Note that this is a goal; it succeeds or it does not.

#+BEGIN_SRC clojure :results pp
  (run* [q] (== 'pea 'pod))
#+END_SRC

#+RESULTS:
: ()
: 

** Frame 11
#+BEGIN_SRC clojure :results pp
  (run* [q] (== q 'pea))
#+END_SRC

#+RESULTS:
: (pea)
: 

We return a list containing =pea= because that's a value of q which would be equivalent to =pea=

** What do I think =run*= is?
Return a list of all possible values of [input variables] that would result in the supplied body of goals succeeding.

** The First Law of ≡

(≡ v w) can be replaced by (≡ w v).

** value associated with

- what is the value of :: returns the output of =run*=
- what is the value associated with :: returns the contents of =run*= without that outer list.


We do this to remove that outer list which we often don't care about.

** frame 15 (non-freshness)

A variable stops being fresh when we assign it a value to make goals succeed.

For example, in =(run* [q] (== q 'pea))=, =q= stops being fresh because we end up assigning th evalue ='pea= to it.

** frame 16 (freshness)
A variable remains fresh if we never assign it a value.

For example, in =(run* [q] s#)=, =q= remains fresh because there is no specific value that makes =s#= succeed, since =s#= *always* succeeds.

** freshness quote

"Every variable is initially fresh. A variable is no longer fresh if it becomes associated with a non-variable value or if it becomes
associated with a variable that, itself, is no longer fresh."

So I guess if variable =q= is set to equal =p=, we need to figure out what =p= is before knowing if =q= is fresh or not.

** Frame 18, 19, 20

#+BEGIN_SRC clojure :results pp
  (run* [q] s#)
#+END_SRC

#+RESULTS:
: (_0)
: 

#+BEGIN_SRC clojure :results pp
  (run* [q] (== 'pea 'pea))
#+END_SRC

#+RESULTS:
: (_0)
: 

#+BEGIN_SRC clojure :results pp
  (run* [q] (== q q))
#+END_SRC

#+RESULTS:
: (_0)
: 

=(_0)= means that =q= remains fresh. In this book's lingo it means that the variable was *reified*

** Frame 23

We can use =(fresh)= to introduce new variables other than the one whose values we care about

#+BEGIN_SRC clojure :results pp
  (run* [q]
    (fresh [x]
      (== 'pea q)))
#+END_SRC

#+RESULTS:
: (pea)
: 

See how we don't care about =x=, but it remains fresh above. =q= in this case gets assigned the value ='pea= to make the goal succeed.

** Frame 24
#+BEGIN_SRC clojure :results pp
  (run* [q]
    (fresh [x]
      (== 'pea x)))
#+END_SRC

#+RESULTS:
: (_0)
: 

In this case, while =x= get associated with ='pea= to make the goal succeed, but =q= remains fresh as its value is irrelevant for the success of any goals.

** Frame 25

#+BEGIN_SRC clojure :results pp
  (run* [q]
    (fresh [x]
      (== (cons x '()) q)))
#+END_SRC

#+RESULTS:
: ((_0))
: 

Note they asked us for the /value associated with/, not the value. This means the book prints only the inner list.

While =q= equals ~(x)~ in this case, =x= is never assigned a value so it gets reified as =_0=.

** Frame 26

Apparently I can't quasiquote in core.logic, I have to break things into lists and symbols.

#+BEGIN_SRC clojure :results pp
  (run* [q]
    (fresh [x]
      (== (list x) q)))
#+END_SRC

#+RESULTS:
: ((_0))
: 

This is the same as Frame 25 but showing that quasiquotes can be used instead of explicitly consing values together.

** Frame 29

We can use ~(== a b)~ to say that the fresh variable a is the same as the fresh variable b. This is called *fusing*.

** Frame 33
#+BEGIN_SRC clojure :results pp
  (run* [q]
    (== (list (list (list 'pea)) 'pod) (list (list (list 'pea)) q)))
#+END_SRC

#+RESULTS:
: (pod)
: 

In order to make this goal succeed, =q= as to be =pod=

** Frame 35
#+BEGIN_SRC clojure :results pp
  (run* [q]
    (fresh [x]
      (== (list (list (list q)) 'pod) (list (list (list x)) 'pod))))
#+END_SRC

#+RESULTS:
: (_0)
: 

In this case =q= and =x= fuse together and have the same value every time this goal succeeds, but we never need to assign q/x a value because any value will do. They remain fresh.
** Frame 36
#+BEGIN_SRC clojure :results pp
  (run* [q]
    (fresh [x]
      (== (list (list (list q)) x) (list (list (list x)) 'pod))))
#+END_SRC

#+RESULTS:
: (pod)
: 

Because these two lists are structurally the same, we know that the =pod= in the last list's last position maps to the =x= in the first lists' last position. And this means that the =x= in the last list's first position is =pod=, and since =q= structunrally maps to =x= (i.e. =q= is fused with =x=), we know that it too is =pod=. And thus, =pod= is associated to the variable =q=.

** Frame 37
#+BEGIN_SRC clojure :results pp
  (run* [q]
    (fresh [x]
      (== (list x x) q)))
#+END_SRC

#+RESULTS:
: ((_0 _0))
: 

We see that ~q~ is ~(x x)~, but we don't assign any variable to =x=, so we see that =q= is a pair of =x= values, reified as =(_0 _0)=. I don't know whether this means that =q= is fresh or not; it has a clear structure so therefore isn't entirely undefined, but contains fresh subcomponents.
** Realization about reified variables.
Fresh variables are possibly only reified when I print the result because I need to represent the fresh variables _somehow_, so the reification assigns the variable a value that isn't valid for computation but makes sense in the context of representing the expression. The variable still however doesn't have any value if it was to be used in other computations (if that's even possible.)

** Frame 38
#+BEGIN_SRC clojure :results pp
  (run* [q]
    (fresh [x]
      (fresh [y]
	(== (list q y) (list (list x y) x)))))
#+END_SRC

#+RESULTS:
: ((_0 _0))
: 

Basically plug values int oeach other, and at the end, =x= is fused to =y= and =q= shows itself to be =(x y)= which basically means =(x x)= or =(y y)=, and thus gets reified as =(_0 _0)=
** Frame 39 - When are two variables different?
Two variables are different when they have not been fused.

When introduced as either fresh variables or run* input variables, all variables are considered different from each other.

** Frame 41

Here we see what happens when you reify two variables that haven't been fused. =q= maps to =(x y)=, but =x= and =y= have not been fused and thus must be shown as different.

#+BEGIN_SRC clojure :results pp
  (run* [q]
    (fresh [x]
      (fresh [y]
	(== (list x y) q))))
#+END_SRC

#+RESULTS:
: ((_0 _1))
: 

This is why we see a pair of =_0 _1_=, because these two fresh variables are different, their values can be any two different ones.

** Frame 43
#+BEGIN_SRC clojure :results pp
  (run* [q]
    (fresh [x]
      (fresh [y]
	(== (list x y x) q))))
#+END_SRC

#+RESULTS:
: ((_0 _1 _0))
: 

Here we see that =q= is =x y x=, and =x= and =y= remain fresh. As such, when we reify we'll see two =_0= reifications and one _1= reification.

=x= reifies to =_0= because it's the first variable we encounter.

** Frame 48/49

- occurrence :: A variable =x= occurs in variable =v= when it appears in the value associated with =v=.

- occurrence :: A variable =x= occurs in list =l= when it or any variable fused with =x= is an element of list =l=, or occurs in any element of =l= (i.e. recursive).

** The Second Law of ≡
If x is fresh, then (≡ v x) succeeds and associates v with x, unless x occurs in v.

** Frame 50
#+BEGIN_SRC clojure :results pp
  (run* [q]
    s#
    s#)
#+END_SRC

#+RESULTS:
: (_0)
: 

=core.logic= don't have conj2 and disj2, I don't have a reference guide, but based on https://github.com/clojure/core.logic/wiki/A-Core.logic-Primer#user-content-Logic_Programming I think that conjunctions (AND) are implicitly the body or =run*= and =fresh= and disjunctions (OR) are defined as branches of something called =conde=
** Frame 51
#+BEGIN_SRC clojure :results pp
  (run* [q]
    s#
    (== 'corn q))
#+END_SRC

#+RESULTS:
: (corn)
: 

=true= && ('corn == q)
** Frame 52
#+BEGIN_SRC clojure :results pp
  (run* [q]
    u#
    (== 'corn q))
#+END_SRC

#+RESULTS:
: ()
: 

q is associated with no value, because no value would satisfy (~false && ('corn == q)~)
** Frame 53
#+BEGIN_SRC clojure :results pp
  (run* [q]
    (== 'meal q)
    (== 'corn q))
#+END_SRC

#+RESULTS:
: ()
: 

=q= can't be =corn= and =meal= at the same time.
** Frame 56
#+BEGIN_SRC clojure :results pp
  (run* [q]
    (conde 
     [(== 'olive q)]
     [u#]))
#+END_SRC

#+RESULTS:
: (olive)
: 

~(q == 'olive) || false~
** Frame 58
#+BEGIN_SRC clojure :results pp
  (run* [q]
    (conde 
     [(== 'olive q)]
     [(== 'oil q)]))
#+END_SRC

#+RESULTS:
: (olive oil)
: 

~(q == 'olive) || (q == 'oil)~, so =q= can be either of these two values, so our value is a list of the two qualifying values of =q=.
** Frame 59
#+BEGIN_SRC clojure :results pp
  (run* [q]
    (fresh [x]
      (fresh [y]
	(conde
	 [(== (list x y) q)]
	 [(== (list y x) q)]))))
#+END_SRC

#+RESULTS:
: ((_0 _1) (_0 _1))
: 

We haven't fused =x= and =y=, so while we don't associate a value with any of these variables, we cannot consider them the same. Also, being a disjunction where both branches can potentially succeed, we have to provide a value for both of them, reifying variables in order of showing up in each sub-expression.

Also, remember that since each branch is a new value, our reification numbering start anew from the first variable encountered.
** Reminder about conde 
(An implementation node ... I have to remember that each disjunction branch has to be wrapped in a list =[ ]= otherwise I am using a single OR branch with two ANDed components....

For example,

#+BEGIN_SRC clojure :results pp
  (run* [q]
    (fresh [x]
      (fresh [y]
	(conde [(== (list x y) q)
		(== (list y x) q)]))))
#+END_SRC

#+RESULTS:
: ((_0 _0))
: 

effectively means a conjunction between two goals since the conde disjunction has only one branch, whereas the frame actually wanted two conde branches to make a disjunction between those same two expressions.
** Frame 61

#+BEGIN_SRC clojure :results pp
  (run* [x]
    (conde [(== 'oil x)]
	   [(== 'olive x)]))
#+END_SRC  

#+RESULTS:
: (oil olive)
: 

#+BEGIN_SRC clojure :results pp
  (run* [x]
    (conde [(== 'olive x)]
	   [(== 'oil x)]))
#+END_SRC

#+RESULTS:
: (olive oil)
: 

When evaluating equivalence between output values, the order doesn't matter. So in this case, the value of these two expressions are equivalent.
** Frame 65
#+BEGIN_SRC clojure :results pp
  (run* [x]
    (conde [(== 'virgin x) u#]
	   [(conde [(== 'olive x)]
		   [(conde [s#]
			   [(== 'oil x)])])]))
#+END_SRC

#+RESULTS:
: (olive _0 oil)
: 

It looks like we have to consider every branch of a conde, even if they are trivial, for successful values, independantly of other branches. This is why our value includes a _0, because there is a branch where success is guaranteed regardless of value._

What is interesting is that we omit values, including a ~()~, for that first =conde= branch which cannot ever be successful. So we only ever gather successes.
** Frame 79
Ah here we learn that =run= and =fresh= body sequences are effectively conjunctions.
** Frame 72 - defrel

#+BEGIN_SRC clojure :results pp
  (defn teacupo [t]
    (fn [s]
      (fn []
	((conde [(== t 'tea)]
		[(== t 'cup)])
	 s))))
#+END_SRC

#+RESULTS:
: #'user/teacupo
: 

I don't really understand this, but I see a bunch of thunking, and the notes say that it is important that =s=, while being passed through into the =conde= which returns a function result, is never referenced in the argument list or body of the "relation" we actually care about (it is thunking infrastructure.)

This is why we use a macro, to hide that secret passthru value. The book advertises scheme's hygienic macros for this reason. I don't understand, and we'll come back to this later.
** Frame 73 - Definition of a relation
A relation is a function that returns a goal.

Relations by convention have names which end with the letter o; hence =teacupo=.
** Frame 86

#+BEGIN_SRC clojure :results pp
  (run* [x y]
    (teacupo x)
    (teacupo x))
#+END_SRC

#+RESULTS:
: ([tea _0] [cup _0])
: 

This is a conjunction, so when we evaluate the second teacupo call, s has already been bound to a value. This is why we only have two tuples. If this was a disjunction I bet we'd have four because we'd need to evaluate the disjunction branches independantly.

#+BEGIN_SRC clojure :results pp
    (run* [x y]
      (conde [(teacupo x)]
	     [(teacupo x)]))
#+END_SRC

#+RESULTS:
: ([tea _0] [tea _0] [cup _0] [cup _0])
: 

Yup.
** Frame 92 - Introduces =conde=
=conde= can be used in place of =conj2= and =disj2=. Which is why =core.logic= doesn't have it.
** The law of =conde=
Every successful =conde= line contributes one or more values.
* Chapter 2 - Teaching Old Toys New Tricks
** Frame 5 (now that we've implemented =caro=)
#+BEGIN_SRC clojure :results pp
  (run* [r]
    (fresh [x y]
      (caro (list r y) x)
      (== 'pear x)))
#+END_SRC

#+RESULTS:
: (pear)
: 
** Frame 9
Variables introduced by =fresh= are values, and regular scheme-like functions can take values as input

(as compared to =conso= which can take outputs like =r= because they are relations?)
** Frame 12
=unnesting= will become important, using =fresh= variables and unpacking ~(car (cdr (cdr (cdr ...))))~ into as many fresh variables as needed and sequences of =cdro= like ~(cdro l v); (cdr v w); (cdr w z); (cdr w ...) ...)~
** Frame 26
;; Alternate form of =conso= using ~==~ instead of =caro=/=cdro=
#+BEGIN_SRC clojure :results pp
    (defrel conso1 [a d p]
      (== (lcons a d) p))
#+END_SRC

#+RESULTS:
: ((a b c d e))
: 
** The Translation (Initial)
To translate a function into a relation, first replace =define= with =defrel=. Then unnest each expression in each =cond= line, and replace each =cond= with =conde=. To unnest a =true=, replace it with =s#=. To unnest a =false=, replace it with =u#=

(what does unnesting mean?)
** Frame 65
I guess unnesting means turn an scheme/clojure expression into a set of reasonedschemer? exceptions, since you often need to split a nested scheme expression into a series of fresh declarations, intermediate variables, and translated function invocations.
** The law of u#
Any =conde= line that has =u#= as a top-level goal cannot contribute values.
** Define both =caro= and =cdro= using =conso=
#+BEGIN_SRC clojure :results pp
  (defrel caro1 [p a]
    (fresh [d]
      (conso a d p)))

  (defrel cdro1 [p d]
    (fresh [a]
      (conso a d p)))
#+END_SRC

#+RESULTS:
: #'user/cdro1
: 
